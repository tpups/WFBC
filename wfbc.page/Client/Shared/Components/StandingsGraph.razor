@using WFBC.Shared.Models
@inject IJSRuntime JSRuntime

<div class="border rounded-xl shadow-sm bg-white dark:bg-gray-800 dark:border-gray-700 px-3 pt-6 pb-6 sm:p-6">
    @if (ProgressionData?.Count > 0)
    {
        <!-- Chart Canvas - Responsive Height -->
        <div class="relative chart-container" id="chartContainer-@Year">
            <canvas id="standingsChart-@Year" class="w-full h-full"></canvas>
        </div>

        <!-- Legend and Controls (Future Enhancement) -->
        <div class="mt-4 p-3 bg-gray-50 dark:bg-gray-700 rounded">
            <p class="text-xs text-gray-500 dark:text-gray-400">
                @teamCount teams with @dataPointCount total data points.
            </p>
        </div>
    }
    else
    {
        <div class="p-8 text-center text-gray-500">
            <div class="mb-4">
                <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                </svg>
            </div>
            <p class="text-lg font-medium">No progression data available</p>
            <p class="text-sm">Ensure standings have been calculated with daily data.</p>
        </div>
    }
</div>

@code {
    [Parameter] public List<Standings> ProgressionData { get; set; } = new();
    [Parameter] public string Year { get; set; } = "2023";

    private int teamCount = 0;
    private int dataPointCount = 0;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ProgressionData?.Count > 0)
        {
            await RenderChart();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (ProgressionData?.Count > 0)
        {
            UpdateDataStats();
            
            // Re-render chart if data changed
            await Task.Delay(100); // Small delay to ensure DOM is ready
            await RenderChart();
        }
    }

    private void UpdateDataStats()
    {
        teamCount = ProgressionData.Select(s => s.TeamId).Distinct().Count();
        dataPointCount = ProgressionData.Count;
    }

    private async Task RenderChart()
    {
        try
        {
            if (ProgressionData?.Count == 0) return;

            // Prepare data for Chart.js
            var chartData = PrepareChartData();
            var canvasId = $"standingsChart-{Year}";

            // Call JavaScript function to render the chart
            await JSRuntime.InvokeVoidAsync("renderStandingsChart", canvasId, chartData, Year);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error rendering chart: {ex.Message}");
        }
    }

    private object PrepareChartData()
    {
        // Group data by team and sort by date
        var teamData = ProgressionData
            .GroupBy(s => s.TeamId)
            .ToDictionary(
                g => g.Key,
                g => g.OrderBy(s => s.Date).ToList()
            );

        // Get all unique dates and sort them
        var allDates = ProgressionData
            .Select(s => s.Date)
            .Distinct()
            .OrderBy(d => d)
            .ToList();

        // Define colors for teams using the chart palette
        var colors = new[]
        {
            "#ffcb51", "#a188ff", "#c2ff48", "#e41973", "#c199bc", "#da5fce",
            "#de704b", "#baba00", "#008eab", "#74c664", "#bba775", "#89cbb3"
        };

        // Create datasets for each team
        var datasets = new List<object>();
        int colorIndex = 0;

        foreach (var team in teamData)
        {
            var teamStandings = team.Value;
            var teamName = teamStandings.FirstOrDefault()?.TeamName ?? $"Team {team.Key}";
            var color = colors[colorIndex % colors.Length];

            // Create data points for each date
            var dataPoints = allDates.Select(date =>
            {
                var standing = teamStandings.FirstOrDefault(s => s.Date.Date == date.Date);
                return standing?.TotalPoints ?? 0;
            }).ToArray();

            datasets.Add(new
            {
                label = teamName,
                data = dataPoints,
                borderColor = color,
                backgroundColor = color,
                fill = false,
                tension = 0.1,
                borderWidth = 2, // Thinner lines for better mobile viewing
                pointRadius = 1.5, // Smaller points
                pointHoverRadius = 4
            });

            colorIndex++;
        }

        return new
        {
            labels = allDates.Select(d => d.ToString("MM/dd")).ToArray(),
            datasets = datasets
        };
    }
}

<style>
    .chart-container {
        height: 300px;
        position: relative;
    }

    .chart-container canvas {
        display: block;
        width: 100% !important;
        height: 100% !important;
    }
</style>

<script>
    let resizeTimeout;
    let resizeListenerAttached = false;

    function getResponsiveChartHeight() {
        const width = window.innerWidth;
        if (width >= 2560) return 900;
        if (width >= 1920) return 800;
        if (width >= 1536) return 700;
        if (width >= 1280) return 600;
        if (width >= 1024) return 500;
        if (width >= 640) return 400;
        return 450; // Increased from 300 to 450 for better mobile experience
    }

    function setResponsiveChartHeight(containerId) {
        const container = document.getElementById(containerId);
        if (container) {
            const height = getResponsiveChartHeight();
            container.style.height = height + 'px';
        }
    }

    window.renderStandingsChart = function(canvasId, chartData, year) {
        const containerId = canvasId.replace('standingsChart-', 'chartContainer-');
        setResponsiveChartHeight(containerId);

        if (window.standingsCharts && window.standingsCharts[canvasId]) {
            window.standingsCharts[canvasId].destroy();
        }

        if (!window.standingsCharts) {
            window.standingsCharts = {};
        }

        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            console.error('Canvas not found:', canvasId);
            return;
        }

        if (!resizeListenerAttached) {
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(function() {
                    Object.keys(window.standingsCharts || {}).forEach(function(chartCanvasId) {
                        const chartContainerId = chartCanvasId.replace('standingsChart-', 'chartContainer-');
                        setResponsiveChartHeight(chartContainerId);
                    });
                }, 250);
            });
            resizeListenerAttached = true;
        }

        const ctx = canvas.getContext('2d');

        if (typeof Chart === 'undefined') {
            console.warn('Chart.js not available. Implementing fallback...');
            renderFallbackChart(canvas, chartData);
            return;
        }

        // Mobile-specific adjustments
        const isMobile = window.innerWidth < 640;
        const borderWidth = isMobile ? 1.5 : 2; // Thinner lines on mobile
        const pointRadius = isMobile ? 1 : 1.5; // Smaller points on mobile

        // Update datasets with mobile-responsive styling
        chartData.datasets.forEach(dataset => {
            dataset.borderWidth = borderWidth;
            dataset.pointRadius = pointRadius;
        });

        const originalDatasets = [...chartData.datasets];
        const lastDateIndex = chartData.labels.length - 1;
        const datasetsOrderedByFinalStandings = originalDatasets.map((dataset, i) => ({
            datasetIndex: i,
            teamName: dataset.label,
            points: dataset.data[lastDateIndex] || 0,
            dataset: dataset
        })).sort((a, b) => b.points - a.points);
        
        chartData.datasets = datasetsOrderedByFinalStandings.map(item => item.dataset);

        window.standingsCharts[canvasId] = new Chart(ctx, {
            type: 'line',
            data: chartData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                resizeDelay: 0,
                plugins: {
                    title: {
                        display: true,
                        text: year + ' World Fantasy Baseball Classic Standings',
                        font: {
                            size: isMobile ? 14 : 16,
                            weight: 'bold'
                        },
                        color: '#1e40af', // WFBC blue
                        padding: {
                            bottom: isMobile ? 10 : 15
                        }
                    },
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: {
                            boxWidth: isMobile ? 8 : 10,
                            padding: isMobile ? 6 : 8,
                            font: {
                                size: isMobile ? 10 : 11
                            },
                            usePointStyle: true,
                            generateLabels: function(chart) {
                                return chart.data.datasets.map((dataset, i) => ({
                                    text: dataset.label,
                                    fillStyle: dataset.borderColor,
                                    strokeStyle: dataset.borderColor,
                                    lineWidth: 1,
                                    hidden: !chart.isDatasetVisible(i),
                                    datasetIndex: i
                                }));
                            }
                        },
                        onClick: function(e, legendItem, legend) {
                            const chart = legend.chart;
                            const index = legendItem.datasetIndex;
                            chart.toggleDataVisibility(index);
                            chart.update();
                        }
                    },
                    tooltip: {
                        displayColors: true,
                        itemSort: function(a, b) {
                            const dateIndex = a.dataIndex;
                            const standingsAtDate = chartData.datasets.map((dataset, i) => ({
                                team: dataset.label,
                                points: dataset.data[dateIndex] || 0,
                                color: dataset.borderColor,
                                datasetIndex: i
                            })).sort((x, y) => y.points - x.points);
                            
                            const aRank = standingsAtDate.findIndex(s => s.team === a.dataset.label);
                            const bRank = standingsAtDate.findIndex(s => s.team === b.dataset.label);
                            
                            return aRank - bRank;
                        },
                        callbacks: {
                            title: function(context) {
                                const dateIndex = context[0].dataIndex;
                                return `Standings for ${chartData.labels[dateIndex]}`;
                            },
                            label: function(context) {
                                const dateIndex = context.dataIndex;
                                const standingsAtDate = chartData.datasets.map((dataset, i) => ({
                                    team: dataset.label,
                                    points: dataset.data[dateIndex] || 0,
                                    color: dataset.borderColor,
                                    datasetIndex: i
                                })).sort((a, b) => b.points - a.points);
                                
                                const teamName = context.dataset.label;
                                const teamRank = standingsAtDate.findIndex(s => s.team === teamName) + 1;
                                const teamPoints = standingsAtDate.find(s => s.team === teamName)?.points || 0;
                                
                                return `${teamRank}. ${teamName}: ${teamPoints} pts`;
                            },
                            labelColor: function(context) {
                                return {
                                    borderColor: context.dataset.borderColor,
                                    backgroundColor: context.dataset.borderColor
                                };
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Date'
                        },
                        grid: {
                            color: '#e5e7eb'
                        }
                    },
                    y: {
                        display: true,
                        title: {
                            display: true,
                            text: isMobile ? 'Points' : 'Total Points'
                        },
                        grid: {
                            color: '#e5e7eb'
                        }
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                hover: {
                    mode: 'index',
                    intersect: false
                }
            }
        });
    };

    function renderFallbackChart(canvas, chartData) {
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#f9fafb';
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = '#6b7280';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Chart.js not loaded', width / 2, height / 2 - 20);
        ctx.fillText('Graph functionality requires Chart.js library', width / 2, height / 2 + 10);
        ctx.font = '12px sans-serif';
        ctx.fillText(`${chartData.datasets.length} teams • ${chartData.labels.length} data points`, width / 2, height / 2 + 40);
    }
</script>
